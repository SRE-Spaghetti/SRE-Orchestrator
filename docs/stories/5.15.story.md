---
Epic: 5
Story: 15
Title: LangGraph Agent and Tool Nodes
Status: Done
---

### Story

As a Developer, I want clearly defined nodes for agent reasoning and tool execution with comprehensive error handling and logging, so that I can understand the workflow, debug issues easily, and modify individual components without affecting others.

### Acceptance Criteria

1. An agent node function invokes the LLM with tools bound
2. The agent node logs execution with timing and correlation information
3. The agent node handles errors gracefully and updates investigation status
4. The agent node includes retry logic for LLM calls
5. A tool node executes tools requested by the LLM
6. The tool node uses LangGraph's prebuilt ToolNode for standard tool execution
7. Tool execution includes comprehensive logging with tool names, arguments, and results
8. Tool errors are handled gracefully and returned as error messages
9. All nodes include correlation_id and incident_id in logs

### Dev Notes

#### Agent Node Design

The agent node is responsible for invoking the LLM to make decisions about the investigation. It reads the current state, calls the LLM with the message history, and returns the LLM's response (which may include tool calls or a final answer).

**Key Responsibilities:**
- Invoke LLM with current messages
- Handle LLM errors and update status
- Retry failed LLM calls
- Log execution and decisions
- Return updated state with LLM response

[Source: `.kiro/specs/native-langgraph-refactoring/requirements.md` Requirement 3]

#### Agent Node Implementation

```python
async def agent_node(state: InvestigationState) -> InvestigationState:
    """
    Agent node that invokes the LLM for reasoning and decision-making.

    This node:
    1. Takes the current state (including message history)
    2. Invokes the LLM with tools bound
    3. Returns updated state with LLM response

    Args:
        state: Current investigation state

    Returns:
        Updated state with LLM response added to messages
    """
    correlation_id = state.get("correlation_id")
    incident_id = state.get("incident_id")

    logger.info(
        "Agent node executing",
        extra={
            "correlation_id": correlation_id,
            "incident_id": incident_id,
            "message_count": len(state["messages"])
        }
    )

    try:
        # model_with_tools captured in closure during graph construction
        response = await retry_async(
            lambda: model_with_tools.ainvoke(state["messages"]),
            DEFAULT_LLM_RETRY_CONFIG,
            correlation_id
        )

        logger.info(
            "Agent node completed",
            extra={
                "correlation_id": correlation_id,
                "incident_id": incident_id,
                "has_tool_calls": bool(response.tool_calls) if hasattr(response, "tool_calls") else False
            }
        )

        # Return partial state - add_messages reducer will append the response
        return {"messages": [response]}

    except Exception as e:
        logger.error(
            "Agent node failed",
            extra={
                "correlation_id": correlation_id,
                "incident_id": incident_id,
                "error": str(e)
            },
            exc_info=True
        )
        # Update status to failed
        return {
            "messages": [],
            "investigation_status": "failed"
        }
```

**Key Design Decisions:**
- **Closure for model**: `model_with_tools` captured during graph construction
- **Retry logic**: Use existing retry_async utility with DEFAULT_LLM_RETRY_CONFIG
- **Partial state updates**: Return only changed fields, reducer handles merging
- **Error handling**: Catch all exceptions and update status

[Source: `.kiro/specs/native-langgraph-refactoring/design.md` Section 2, `.kiro/specs/native-langgraph-refactoring/tasks.md` Task 3]

#### Tool Node Design

The tool node executes tools requested by the LLM. LangGraph provides a prebuilt `ToolNode` that handles most of the heavy lifting, but we can wrap it for additional logging.

**Options:**
1. **Use ToolNode directly** (recommended): Simple, tested, handles edge cases
2. **Custom tool node**: More control, custom logging, custom error handling

[Source: `.kiro/specs/native-langgraph-refactoring/design.md` Section 3]

#### Tool Node Implementation (Prebuilt)

```python
from langgraph.prebuilt import ToolNode

# In graph construction:
graph.add_node("tools", ToolNode(mcp_tools))
```

**Advantages:**
- Handles tool message formatting automatically
- Properly manages tool_call_id tracking
- Battle-tested edge case handling
- Minimal code to maintain

[Source: `.kiro/specs/native-langgraph-refactoring/tasks.md` Task 4.1]

#### Tool Node Implementation (Custom with Logging)

For enhanced logging, we can wrap the prebuilt ToolNode:

```python
async def custom_tool_node(state: InvestigationState) -> InvestigationState:
    """
    Custom tool node that executes tools with enhanced logging.
    """
    correlation_id = state.get("correlation_id")
    incident_id = state.get("incident_id")

    messages = state["messages"]
    last_message = messages[-1]

    if not hasattr(last_message, "tool_calls") or not last_message.tool_calls:
        logger.warning(
            "Tool node called but no tool calls found",
            extra={"correlation_id": correlation_id, "incident_id": incident_id}
        )
        return {"messages": []}

    logger.info(
        "Tool node executing",
        extra={
            "correlation_id": correlation_id,
            "incident_id": incident_id,
            "tool_count": len(last_message.tool_calls),
            "tool_names": [tc["name"] for tc in last_message.tool_calls]
        }
    )

    # Use prebuilt ToolNode for execution
    tool_node = ToolNode(mcp_tools)
    result = await tool_node.ainvoke(state)

    logger.info(
        "Tool node completed",
        extra={
            "correlation_id": correlation_id,
            "incident_id": incident_id,
            "result_message_count": len(result.get("messages", []))
        }
    )

    return result
```

[Source: `.kiro/specs/native-langgraph-refactoring/tasks.md` Task 4.2]

#### Integration with Graph

Both nodes are integrated into the graph during construction:

```python
# Create agent node with model closure
async def agent_node_with_model(state: InvestigationState) -> InvestigationState:
    # Agent node implementation (model_with_tools in closure)
    ...

# Add nodes to graph
graph.add_node("agent", agent_node_with_model)
graph.add_node("tools", ToolNode(mcp_tools))  # or custom_tool_node

# Add edges
graph.add_conditional_edges("agent", should_continue, {"tools": "tools", "end": END})
graph.add_edge("tools", "agent")
```

[Source: `.kiro/specs/native-langgraph-refactoring/design.md` Section 5]

#### Error Handling Strategy

**Agent Node Errors:**
- LLM API failures → Retry with exponential backoff
- Network timeouts → Retry up to max attempts
- Invalid responses → Log and mark investigation as failed
- Unknown errors → Log with full traceback and fail gracefully

**Tool Node Errors:**
- Tool not found → Return error message to LLM
- Tool execution failure → Return error message to LLM
- Invalid arguments → Return error message to LLM
- Network errors → Retry (handled by tool implementation)

[Source: `.kiro/specs/native-langgraph-refactoring/design.md` Error Handling]

### Tasks / Subtasks

- [x] **(AC: 1, 2)** **Implement Agent Node:**
  - Create async agent_node function with InvestigationState parameter
  - Extract correlation_id and incident_id for logging
  - Invoke model_with_tools with state["messages"]
  - Return partial state update with new message
  - Add comprehensive logging for node execution
  - Reference: `.kiro/specs/native-langgraph-refactoring/tasks.md` Task 3.1

- [x] **(AC: 3)** **Add Agent Node Error Handling:**
  - Wrap LLM invocation in try/except
  - Log errors with correlation ID and incident ID
  - Update investigation_status to "failed" on error
  - Return partial state with error status
  - Include exc_info=True for full traceback
  - Reference: `.kiro/specs/native-langgraph-refactoring/tasks.md` Task 3.2

- [x] **(AC: 4)** **Add Agent Node Retry Logic:**
  - Wrap LLM invocation with retry_async utility
  - Use DEFAULT_LLM_RETRY_CONFIG for retry configuration
  - Pass correlation_id to retry function for logging
  - Handle retry exhaustion gracefully
  - Reference: `.kiro/specs/native-langgraph-refactoring/tasks.md` Task 3.3

- [x] **(AC: 5, 6)** **Implement Tool Node:**
  - Import ToolNode from langgraph.prebuilt
  - Create ToolNode instance with mcp_tools
  - Add to graph as "tools" node
  - Reference: `.kiro/specs/native-langgraph-refactoring/tasks.md` Task 4.1

- [x] **(AC: 7, 8, 9)** **Add Custom Tool Execution Logging:**
  - Create wrapper around ToolNode for enhanced logging
  - Log tool invocations with correlation ID and tool names
  - Log tool results with timing information
  - Log tool errors with context
  - Include correlation_id and incident_id in all logs
  - Reference: `.kiro/specs/native-langgraph-refactoring/tasks.md` Task 4.2

- [x] **Unit Tests for Agent Node:**
  - Test agent node with mock LLM
  - Test agent node error handling
  - Test agent node logging
  - Test agent node retry logic
  - Verify state updates are correct
  - Reference: `.kiro/specs/native-langgraph-refactoring/tasks.md` Task 8.3

- [x] **Integration Tests:**
  - Test agent node → routing → tool node flow
  - Test agent node → routing → end flow
  - Test error handling in multi-step workflow
  - Verify message accumulation with add_messages reducer
  - Reference: `.kiro/specs/native-langgraph-refactoring/tasks.md` Task 8.4

- [x] **Update Documentation:**
  - Add detailed docstrings for agent_node function
  - Add detailed docstrings for custom_tool_node function
  - Document error handling strategy
  - Document retry behavior
  - Add code comments for complex logic
  - Reference: `.kiro/specs/native-langgraph-refactoring/tasks.md` Task 9.3

### Change Log

| Date | Version | Description | Author |
| --- | --- | --- | --- |
| 2025-11-15 | 1.0 | Initial draft | Yi (Dev) |

### Dev Agent Record

#### Agent Model Used
Claude Sonnet 4.5

#### Debug Log References
_TBD_

#### Completion Notes List
- Agent node uses closure to capture model_with_tools
- Retry logic reuses existing retry_async utility
- ToolNode from langgraph.prebuilt handles tool execution
- Custom wrapper adds enhanced logging without reimplementing logic
- All nodes include correlation_id and incident_id for tracing
- Error handling is comprehensive and graceful

#### File List
- investigation_agent.py: agent_node and custom_tool_node functions
- tests/test_agent_node.py: Agent node unit tests
- tests/test_tool_node.py: Tool node unit tests
- tests/test_graph_integration.py: Integration tests

### QA Results

- **Status:** Not yet reviewed
- **Date:**
- **Reviewed by:**
- **Summary:**
- **Issues Found:**
- **Recommendations:**
